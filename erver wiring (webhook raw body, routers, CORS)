[1mdiff --git a/apps/api/models/Booking.js b/apps/api/models/Booking.js[m
[1mindex 4b3ad00..4db144f 100644[m
[1m--- a/apps/api/models/Booking.js[m
[1m+++ b/apps/api/models/Booking.js[m
[36m@@ -1,10 +1,9 @@[m
[31m-// apps/api/models/Booking.js[m
 import mongoose from "mongoose";[m
 [m
 /**[m
[31m- * Booking states (kept for back-compat with your server logic):[m
[32m+[m[32m * Booking states:[m
  * - "pending_payment" -> "scheduled" on Paystack success.[m
[31m- * - Added "accepted"/"declined" earlier, keep all.[m
[32m+[m[32m * - "accepted"/"declined" for pro decisions.[m
  */[m
 const STATUS = [[m
   "pending_payment",[m
[36m@@ -64,27 +63,23 @@[m [mconst BookingSchema = new mongoose.Schema([m
 [m
     // Which professional[m
     proId: { type: mongoose.Schema.Types.ObjectId, ref: "Pro", required: true, index: true },[m
[31m-    // ⚠️ Was required before; make optional so routes can infer and save later[m
[32m+[m[32m    // optional; routes infer & set it[m
     proOwnerUid: { type: String, index: true },[m
 [m
[31m-    // What & how much (snapshot; keep amountKobo for back-compat)[m
[32m+[m[32m    // What & how much[m
     service: { type: ServiceSnapshotSchema, required: true },[m
     amountKobo: { type: Number, required: true, min: 1 },[m
     currency: { type: String, default: "NGN" },[m
 [m
     // Scheduling[m
[31m-    // ⚠️ For instant bookings we may not have a chosen timeslot. Make optional.[m
     scheduledFor: { type: Date, index: true },[m
 [m
[31m-    // Instant flag for date/time-less flow[m
[32m+[m[32m    // Instant flow[m
     instant: { type: Boolean, default: false, index: true },[m
 [m
[31m-    // Region support (let routes fill it; don’t block save)[m
[31m-    lga: { type: String, default: "" }, // e.g., "OREDO" (UPPERCASE)[m
[31m-[m
[31m-    // Human-readable address (can match location.text)[m
[32m+[m[32m    // Region (upper-cased)[m
[32m+[m[32m    lga: { type: String, default: "" }, // e.g., "OREDO"[m
     addressText: { type: String, default: "" },[m
[31m-[m
     location: { type: LocationSchema, default: () => ({}) },[m
 [m
     notes: { type: String, default: "" },[m
[36m@@ -98,7 +93,7 @@[m [mconst BookingSchema = new mongoose.Schema([m
     },[m
     paystackReference: { type: String, default: "", index: true },[m
 [m
[31m-    // Payout release flag (scheduler/admin endpoint uses this)[m
[32m+[m[32m    // Payout release flag[m
     payoutReleased: { type: Boolean, default: false },[m
 [m
     // Booking lifecycle[m
[36m@@ -113,7 +108,7 @@[m [mconst BookingSchema = new mongoose.Schema([m
     decline: {[m
       type: new mongoose.Schema([m
         {[m
[31m-          reasonCode: { type: String, default: "" }, // "too_busy" | "out_of_area" | ...[m
[32m+[m[32m          reasonCode: { type: String, default: "" },[m
           reasonText: { type: String, default: "" },[m
           at: { type: Date, default: null },[m
         },[m
[36m@@ -122,25 +117,20 @@[m [mconst BookingSchema = new mongoose.Schema([m
       default: () => ({}),[m
     },[m
 [m
[31m-    // Private client contact (only after accept to assigned pro, and to admins)[m
[32m+[m[32m    // Private client contact (visible to assigned pro after accept, and to admins)[m
     clientContactPrivate: { type: ClientContactPrivateSchema, default: () => ({}) },[m
 [m
[31m-    // Timestamps you already use[m
[32m+[m[32m    // Timestamps[m
     completedAt: { type: Date },[m
   },[m
   { timestamps: true }[m
 );[m
 [m
 /* ------------------------------ Hooks/Virtuals ------------------------------ */[m
[31m-/**[m
[31m- * Keep `amountKobo` in sync with `service.priceKobo` at creation time.[m
[31m- * If caller passes both, trust explicit `amountKobo`.[m
[31m- */[m
 BookingSchema.pre("validate", function (next) {[m
   if (!this.amountKobo && this.service?.priceKobo) {[m
     this.amountKobo = this.service.priceKobo;[m
   }[m
[31m-  // For instant bookings, auto-stamp scheduledFor so downstream code that expects a Date doesn’t crash[m
   if (this.instant && !this.scheduledFor) {[m
     this.scheduledFor = new Date();[m
   }[m
[1mdiff --git a/apps/api/models/wallet.js b/apps/api/models/wallet.js[m
[1mindex d0433ef..ec6a38a 100644[m
[1m--- a/apps/api/models/wallet.js[m
[1m+++ b/apps/api/models/wallet.js[m
[36m@@ -1,35 +1,45 @@[m
 // apps/api/models/wallet.js[m
 import mongoose from "mongoose";[m
 [m
[32m+[m[32m/* =========================== Wallet & Tx Models =========================== */[m
[32m+[m
 const WalletSchema = new mongoose.Schema([m
   {[m
     ownerUid: { type: String, required: true, unique: true, index: true },[m
[31m-    pendingKobo: { type: Number, default: 0 },[m
[31m-    availableKobo: { type: Number, default: 0 },[m
[31m-    withdrawnKobo: { type: Number, default: 0 },[m
[31m-    earnedKobo: { type: Number, default: 0 },[m
[32m+[m
[32m+[m[32m    // For pros you may use pending/earned/withdrawn.[m
[32m+[m[32m    // For clients we mainly use availableKobo as "creditsKobo".[m
[32m+[m[32m    pendingKobo: { type: Number, default: 0, min: 0 },[m
[32m+[m[32m    availableKobo: { type: Number, default: 0, min: 0 },[m
[32m+[m[32m    withdrawnKobo: { type: Number, default: 0, min: 0 },[m
[32m+[m[32m    earnedKobo: { type: Number, default: 0, min: 0 },[m
   },[m
   { timestamps: true }[m
 );[m
 [m
[32m+[m[32m// (Optional) convenient alias used by FE in some places.[m
[32m+[m[32mWalletSchema.virtual("creditsKobo").get(function () {[m
[32m+[m[32m  return this.availableKobo;[m
[32m+[m[32m});[m
[32m+[m
 // Keep transaction types flexible but consistent[m
 const WalletTxSchema = new mongoose.Schema([m
   {[m
     ownerUid: { type: String, required: true, index: true },[m
 [m
[31m-    // e.g. "booking_fund", "release", "withdraw", "withdraw_pending", "fee"[m
[32m+[m[32m    // e.g. "topup", "booking_hold", "booking_release", "refund", "withdraw", "fee"[m
     type: { type: String, required: true },[m
 [m
     // "credit" or "debit"[m
     direction: { type: String, enum: ["credit", "debit"], required: true },[m
 [m
[31m-    amountKobo: { type: Number, required: true },[m
[32m+[m[32m    amountKobo: { type: Number, required: true, min: 1 },[m
 [m
     // snapshot balances after this tx[m
     balancePendingKobo: { type: Number, default: 0 },[m
     balanceAvailableKobo: { type: Number, default: 0 },[m
 [m
[31m-    // anything helpful (bookingId, paystackRef, feeKobo, etc.)[m
[32m+[m[32m    // anything helpful (bookingId, paystackRef, feeKobo, intentId, etc.)[m
     meta: { type: mongoose.Schema.Types.Mixed, default: {} },[m
   },[m
   { timestamps: true }[m
[36m@@ -38,10 +48,31 @@[m [mconst WalletTxSchema = new mongoose.Schema([m
 // helpful index for recent history per user[m
 WalletTxSchema.index({ ownerUid: 1, createdAt: -1 });[m
 [m
[32m+[m[32m/**[m
[32m+[m[32m * Top-up intent: created before redirect/inline; verified once by Paystack callback.[m
[32m+[m[32m * Prevents replay; links a reference to an amount and owner.[m
[32m+[m[32m */[m
[32m+[m[32mconst WalletTopupIntentSchema = new mongoose.Schema([m
[32m+[m[32m  {[m
[32m+[m[32m    ownerUid: { type: String, required: true, index: true },[m
[32m+[m[32m    reference: { type: String, required: true, unique: true, index: true }, // Paystack ref[m
[32m+[m[32m    amountKobo: { type: Number, required: true, min: 1 },[m
[32m+[m[32m    status: { type: String, enum: ["created", "verified", "failed"], default: "created", index: true },[m
[32m+[m[32m    meta: { type: mongoose.Schema.Types.Mixed, default: {} }, // any provider payload[m
[32m+[m[32m    verifiedAt: { type: Date, default: null },[m
[32m+[m[32m  },[m
[32m+[m[32m  { timestamps: true }[m
[32m+[m[32m);[m
[32m+[m
 export const Wallet =[m
   mongoose.models.Wallet || mongoose.model("Wallet", WalletSchema);[m
 export const WalletTx =[m
   mongoose.models.WalletTx || mongoose.model("WalletTx", WalletTxSchema);[m
[32